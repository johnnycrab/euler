package crabMath

//import "fmt"

// returns a slice of integers with coprime numbers up to `n`.
// if `odd` is true, then only odd numbers are returned, otherwise only even numbers
func pythCoprimeNums(n int, primeFactors []int, odd bool) []int {
	coprimes := []int{}

	nums := make([]int, n)

	usedFactors := []int{}

	for _, p := range primeFactors {

		if IntSliceContains(usedFactors, p) {
			continue
		}

		usedFactors = append(usedFactors, p)

		for k := 1; k*p <= n; k++ {
			nums[k*p - 1] = 1
		}
	}

	for i, v := range nums {
		if ((odd && (i+1)%2 == 1) || (!odd && (i+1)%2 == 0)) && v == 0 {
			coprimes = append(coprimes, i+1)
		}
	}

	return coprimes
}

/*
	Each primitive Pythagorean triple a,b,c > 0 can be generated by a pair of natural numbers
	m > n > 0 with gcd(m,n) = 1
	by: a = m^2-n^2, b = 2mn, c = m^2 + n^2


	Each Pythagorean triple can then be uniquele generated by m,n as above and arbitrary k > 0 
	by multiplying a,b,c with k

	This function will return a slice of integer triples which represent a,b,c as above, with m <= maximalValue

*/
func GetPrimitivePythagoreanTriples(maximalValue int) [][3]int {

	triples := [][3]int{}
	primeSieve := PrimeSieve(maximalValue)

	for m := 2; m <= maximalValue; m++ {
		
		_, factors := SimplePrimeFactorizationWithSieve(m, primeSieve)
		odd := (m%2 == 0)
		coprimes := pythCoprimeNums(m, factors, odd)
		// fmt.Println(coprimes)

		for _, n := range coprimes {
		//	fmt.Println(m, n)
			
			triple := [3]int{m*m - n*n, 2*m*n, m*m + n*n}
		//	fmt.Println(triple)
		//	fmt.Println("-----")
			triples = append(triples, triple)
		}
	}

	return triples
}